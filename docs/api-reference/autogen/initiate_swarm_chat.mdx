---
sidebarTitle: initiate_swarm_chat
title: autogen.initiate_swarm_chat
---

<code class="doc-symbol doc-symbol-heading doc-symbol-function"></code>
#### initiate_swarm_chat

```python
initiate_swarm_chat(
    initial_agent: autogen.agentchat.conversable_agent.ConversableAgent,
    messages: list[dict[str, typing.Any]] | str,
    agents: list[autogen.agentchat.conversable_agent.ConversableAgent],
    user_agent: autogen.agentchat.user_proxy_agent.UserProxyAgent | None = None,
    swarm_manager_args: dict[str, typing.Any] | None = None,
    max_rounds: int = 20,
    context_variables: dict[str, typing.Any] | None = None,
    after_work: autogen.agentchat.contrib.swarm_agent.AfterWorkOption | Callable[..., Any] | None = AfterWork(agent=<AfterWorkOption.TERMINATE: 'TERMINATE'>, next_agent_selection_msg=None)
) -> tuple[autogen.agentchat.chat.ChatResult, dict[str, typing.Any], autogen.agentchat.conversable_agent.ConversableAgent]
```

    Initialize and run a swarm chat

<b>Parameters:</b>
| Name | Description |
|--|--|
| `initial_agent` | The first receiving agent of the conversation.<br/><br/>**Type:** `autogen.agentchat.conversable_agent.ConversableAgent` |
| `messages` | Initial message(s).<br/><br/>**Type:** `list[dict[str, typing.Any]] \| str` |
| `agents` | List of swarm agents.<br/><br/>**Type:** `list[autogen.agentchat.conversable_agent.ConversableAgent]` |
| `user_agent` | Optional user proxy agent for falling back to.<br/><br/>**Type:** `autogen.agentchat.user_proxy_agent.UserProxyAgent \| None`<br/><br/>**Default:** None |
| `swarm_manager_args` | Optional group chat manager arguments used to establish the swarm's groupchat manager, required when AfterWorkOption.SWARM_MANAGER is used.<br/><br/>**Type:** `dict[str, typing.Any] \| None`<br/><br/>**Default:** None |
| `max_rounds` | Maximum number of conversation rounds.<br/><br/>**Type:** `int`<br/><br/>**Default:** 20 |
| `context_variables` | Starting context variables.<br/><br/>**Type:** `dict[str, typing.Any] \| None`<br/><br/>**Default:** None |
| `after_work` | Method to handle conversation continuation when an agent doesn't select the next agent.<br/><br/>If no agent is selected and no tool calls are output, we will use this method to determine the next agent.<br/><br/>Must be a AfterWork instance (which is a dataclass accepting a ConversableAgent, AfterWorkOption, A str (of the AfterWorkOption)) or a callable.<br/><br/>AfterWorkOption: - TERMINATE (Default): Terminate the conversation.<br/><br/>- REVERT_TO_USER : Revert to the user agent if a user agent is provided.<br/><br/>If not provided, terminate the conversation.<br/><br/>- STAY : Stay with the last speaker.<br/><br/>Callable: A custom function that takes the current agent, messages, and groupchat as arguments and returns an AfterWorkOption or a ConversableAgent (by reference or string name).<br/><br/>```def custom_afterwork_func(last_speaker: ConversableAgent, messages: List[Dict[str, Any]], groupchat: GroupChat) -> Union[AfterWorkOption, ConversableAgent, str]: ```<br/><br/>**Type:** `autogen.agentchat.contrib.swarm_agent.AfterWorkOption \| Callable[..., Any] \| None = AfterWork(agent`<br/><br/>**Default:** AfterWorkOption.TERMINATE |

<b>Returns:</b>
| Type | Description |
|--|--|
| `tuple[autogen.agentchat.chat.ChatResult, dict[str, typing.Any], autogen.agentchat.conversable_agent.ConversableAgent]` | ChatResult: Conversations chat history. Dict[str, Any]: Updated Context variables. ConversableAgent: Last speaker. |

<br />